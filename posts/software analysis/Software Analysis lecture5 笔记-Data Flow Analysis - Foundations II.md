# Software Analysis lecture5 笔记-Data Flow Analysis - Foundations II

这一节是数据流分析的最后一节课，回顾上一节课中提出的三个问题，尽管上节课已经讲到了格理论和不动点定理，但是仍然没有得到回答，原因是不动点定理只是适用于格上定义的函数，接下来要做的就是讲迭代算法关联到格上的函数，证明迭代算法满足格上函数的性质，output的值域关联到格，才可以说不动点定理适用于迭代算法。

给定一个全格 $$ L \le $$，若满足：

1. $$ F:L \rightarrow L是单调的
2. $$ L是有穷的 $$

那么就说F的最小不动点能通过应用一系列的迭代 $$ F(\bot), F(F(\bot))...F^k(\bot)$$到达，F的最大不动点能通过应用一系列的迭代 $$ F(\top), F(F(\top))...F^k(\top) $$ 到达。

证明L是有穷：

因为控制流中的k个结点关联的输出可以看作全格L_k，所以整个控制流的状态可以用一个格的积 $$ L^k $$ 来表示，因为所有L都是全格，所以L^k也是全格。所以L^k是有穷的。

证明函数F的单调性：

函数F可以看作由两部分组成，一是每一个结点上的转换函数f:L->L,二是分支汇聚处发生join/meet, 分别证明一和二是单调的既可证明F是单调的。

由前面的课程可知，迭代算法中的转换函数都为generate/kill这种形式的函数，而这种函数必定是单调的，证明如下：

因为每个语句的generate和kill在一个分析中自始至终不变，所以可以合并为一个常量c，又因为语句s的输入输出关系为f(S_in) = S_in + c = S_out，S_in = \bitcup Pre(s)_out，假设S仅有两个分支，第一轮迭代的时候有一分支a的out为000，一个分支b为xxx，便有000 \cup xxx \cup c= xxx \cup c， 第二轮的时候分支a的yyy必然大于等于000，所以必然有yyyy \cup xxx \cup c >= 000 \cup xxx \cup c，而\cup操作只会发生0 \cup 0 = 0，0 \cup 1 = 1，1 \cup  = 1，所以f必然是单调的， 

分支汇聚处的join是单调的，证明如下：
