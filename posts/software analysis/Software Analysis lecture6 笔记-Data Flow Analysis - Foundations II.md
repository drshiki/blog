# Software Analysis lecture6 笔记-Data Flow Analysis - Foundations II

这一节是数据流分析的最后一节课，回顾上一节课中提出的三个问题，尽管上节课已经讲到了格理论和不动点定理，但是仍然没有回答问题。原因是不动点定理只适用于格上定义的函数，接下来要做的就是将迭代算法关联到格上定义的函数，证明迭代算法满足格上函数的性质，out[s]的值域关联到格，才可以将不动点定理应用于迭代算法。

给定一个全格L，若满足：

1. $$ F:L \rightarrow L $$ 是单调的
2. L是有穷的

那么就说F的最小不动点能通过一系列的迭代 $$ F(\bot), F(F(\bot))...F^k(\bot) $$ 到达，F的最大不动点能通过一系列的迭代 $$ F(\top), F(F(\top))...F^k(\top) $$ 到达。

**首先证明L是有穷：**

因为控制流中k个结点上的每个结点的输出都可以看作全格L，所以整个控制流的状态可以用一个格的积 $$ L^k $$ 来表示，因为所有L都是全格，所以 $$ L^k $$ 也是全格，且 $$ L^k $$ 是有穷的。

**证明函数F的单调性：**

函数F可以看作由两部分组成，1是每一个结点上的转换函数 $$ f:L \ rightarrow L $$，2是分支汇聚处的join/meet, 分别证明1和2是单调的即可证明F是单调的。

由前面的课程可知，迭代算法中的转换函数都为generate/kill这种形式的函数，而这种函数必定是单调的。证明如下：

因为 $$ OUT[s] = IN[s] + gen_s - kill_s $$，又因为结点的 $$ gen_s $$ 和 $$ kill_s $$ 是不变的，所以可以合并成一个常量c，故有 $$ OUT[s] = IN[s] + c $$，又因为IN[s]上的每一位经过转换函数后变成OUT[s]，它上面的每一位只可能从0变成0或者1，从1变成1，不可能从1变成0，所以可知转换函数是单调的；

证明分支汇聚处的join是单调的，这里仅写出join的证明，meet的证明思路是一样的，证明如下：

$$ \forall x, y, z \in L, x \le y $$，证明 $$ x \sqcup z \le y \sqcup z $$ 即可证明join是单调的

按 $$ \sqcup $$ 定义有， $$ y \le y \sqcup z $$

根据 $$ \le $$ 的传递性有， $$ x \le y \sqcup z $$

因为 $$ y \sqcup z $$ 是x的一个上界，也是z的一个上界

又因为 $$ x \sqcup z $$ 是x和z的最小上界，所以必然有 $$ x \sqcup z \le y \sqcup z $$

QED

因为转换函数是单调的，join/meet操作也是单调的，所以F必然是单调的。

到此，已经可以关联迭代算法到格上了，根据不动点定理，就可以回答之前三个问题的前两问：算法必然可以停止（到达不动点）；到达的不动点一点是最好的不动点（最大不动点或者最小不动点）。还有第三个问题亟待解答。

在回答第三个问题之前，介绍一下一个格的高度，一个格的高度为最低点（bottom）到最高点（top）之间的最长路径。

![](6/20200526002636.jpg)

这个时候再看迭代算法的最坏情况下到底需要运行多少次才能停止。如果每一个循环只让格的k元组$$ (L, L, L, L...) $$ 中的仅一个格爬升了一层，用我们之前的算法来说就是一个循环中只改变了所有结点中一个结点的OUT的一个bit，这个就是最坏情况，这种情况下，算法会运行k\*h步才会停止，这也就回答了第三个问题，迭代算法的最坏时间复杂度为h\*k，其中h为格的高度，k为cfg的结点数。

接下来用格结合之前知识，用图例的方式给出一个综合上的理解：

![](6/20200524182305.jpg)

## MOP


